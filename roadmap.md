## 数据结构  
- [ ] 动态数组  
- [ ] 单向链表  
- [ ] 双向链表  
- [ ] 堆  
- [ ] 栈  
- [ ] 队列  
- [ ] 优先级队列  
- [ ] 哈希表   
- [ ] 按位运算  
- [ ] 树 (遍历) 
  - [ ] 二叉查找树 BSTs  
  - [ ] 堆 (Heap) / 优先级队列 (Priority Queue) / 二叉堆 (Binary Heap)  
  - [ ] 字典树 (Tries）  
  - [ ] 平衡查找树 (Balanced search trees)  
  - [ ] AVL树  
  - [ ] 伸展树  
  - [ ] 2-3树  
  - [ ] 2-3-4树 (亦称2-4树)  
  - [ ] B树  
  - [ ] 红黑树  
  - [ ] N 叉树 (K 叉树、M 叉树)  
- [ ] 图 (Graphs)
  - [ ] 最近对 [蛮力] Θ(n^2)
  - [ ] 凸包   [蛮力] Θ(n^3)
  - [ ] 深度优先 - DFS - [递归]（用栈） - 一个人走迷宫
  - [ ] 广度优先 - BFS - [迭代]（用队列）- 一群人走迷宫
- [ ] 字符串

## 算法  
- [ ] 查找
  - [ ] 顺序 [蛮力] O(n)
  - [ ] 字符串匹配 [蛮力] Worst:O(nm)  Avg:O(n+m)~Θ(n)
  - [ ] 二分查找 /折半 [分治]   Worst:Θ(logn)
- [ ] 排序 (Sorting)
  - [ ] 冒泡排序 [蛮力] O(n^2)
  - [ ] 选择排序 [蛮力] O(n^2)
  - [ ] 插入排序  
  - [ ] 合并排序 [分治] O(n·logn) -> n·logn-1.44n
  - [ ] 快速排序 [分治] 找分区切点 Avg:O(1.39n·logn) Worst:Θ(n^2) 
 
  
- [ ] 递归 (Recursion)   
- [ ] 回溯  
- [ ] 贪心   
- [ ] 动态规划 (Dynamic Programming)   
- [ ] 组合 (Combinatorics) & 概率 (Probability)    
- [ ] NP, NP-完全和近似算法    


- [ ] 旅行商问题 => 求图的最短哈密顿回路问题（每个顶点只经过1次）Θ(n!)  
- [ ] 背包问题 Θ(2^n)  伪多项式级算法
- [ ] 分配问题  
- [X] 循环赛问题 == 握手问题 == 一个含有n个节点的完全图有多少条边  n*(n-1)/2
- [X] 淘汰赛问题 == 龟兔赛跑问题 == n-1  
- [X] 排列问题，本质上是顺序问题。 C(n,k) n选k  


  
    
       
          
            





🍗二分查找 [Binary Search](https://leetcode.com/explore/learn/card/binary-search/)  
[[search-a-2d-matrix]](https://oj.leetcode.com/problems/search-a-2d-matrix/)  


[69. Sqrt(x)](https://leetcode.com/problems/sqrtx/description/) [resolved](/algs/BinarySearch/Sqrtx.js)